#pragma once

#include <vector>
#include <typeindex>
#include <future>

#include <PerlinNoise\PerlinNoise.h>

#include "MapBuilderCore\APIExport.h"
#include "MapBuilderCore\Module.h"
#include "MapBuilderCore\payloads\Heightmap.h"
#include "MapBuilderCore\util\ModuleHelpers.h"

namespace mbc
{
  /*
  Module applies Perlin noise to the Heightmap payload, multiplying each height
  value by the percentage generated by the Perlin function. Each percentage is
  generated with the seed, frequency, and octaves parameter. Two modules given
  the same processing parameters and base heightmap will produce identical
  results.
  */
  class MAPBUILDER_API PerlinGen : public Module
  {
  public:
    PerlinGen();
    PerlinGen::Ptr clone() const override;

    // Inherit from base class - must be implemented
    TypeIndexVector registerTypes(PayloadFactory&) override;
    bool processPayloads(const PayloadTypeMap&) override;

    bool operator==(Module::Ptr) override;
    bool operator!=(Module::Ptr) override;

    // Processing parameters
    uint32_t seed;
    double frequency;
    uint32_t octaves;

    // Serialize module
    template<typename Archive>
    void serialize(Archive& archive);

  };

  /* Function to be called asynchronously to compute the 2D perlin grid in
    parallel. */
  void computePerlinGrid(unsigned char* begin, unsigned char* end,
    const double& fx, const double& fy, const uint32_t& oct,
    const int& startIndex, const int& width, const uint32_t& seed);
}


// Inline definitions for operator overloads
inline bool mbc::PerlinGen::operator==(Module::Ptr other)
{
  auto castOther = std::dynamic_pointer_cast<PerlinGen>(other);
  if (castOther)
  {
    return (seed == castOther->seed
      && frequency == castOther->frequency
      && octaves == castOther->octaves);
  }  // Return false if other cannot be cast to this Module.

  return false;
}


inline bool mbc::PerlinGen::operator!=(Module::Ptr other)
{
  return !(this->operator==(other));
}


template<typename Archive>
inline void mbc::PerlinGen::serialize(Archive& archive)
{
  archive(
    CEREAL_NVP(seed),
    CEREAL_NVP(frequency),
    CEREAL_NVP(octaves)
  );
}


CEREAL_REGISTER_TYPE(mbc::PerlinGen);
CEREAL_REGISTER_POLYMORPHIC_RELATION(mbc::Module, mbc::PerlinGen);
